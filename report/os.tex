\section{Operational Semantics}
\label{sec:os}
The operational semantics of a programming language is used to interpret a valid program into sequences of computational steps. And these sequences are the meaning of the program. In this section, I will describe the operational semantics for the generator feature.

\subsection{Sequence}
The \textit{seq} term can be constructed by taking two terms, where both could be \textit{seq} terms. 
\textbf{ST_Seq1}: If t1 is a \textit{seq} term, then concatenate t1 with t2. 
\textbf{ST_Seq2}: If t1 is not a \textit{seq} term, then reduce t1 to t1'. 
\textbf{ST_Seq3}: If v1 is a \textit{yield} term, then return a \textit{exit} pair. 
\textbf{ST_Seq4}: If v1 is not a \textit{yield} term, then return a t2.
\begin{lstlisting}
Inductive yield_tm : tm -> Prop :=
| Tgyield : forall t, yield_tm (gyeild t).

Inductive seq_tm : tm -> Prop :=
| Tseq : forall t1 t2, seq_tm (seq t1 t2).

Fixpoint seqCat (s : tm) (t : tm) : tm :=
match s with
| seq t1 t2 => seq t1 (seqCat t2 t)
| t' => seq t' t
end.

Reduction:

									    		seq_tm t1
								---------------------------------  (ST_Seq1)
								seq t1 t2 / st --> seqCat t1 t2 / st
								
											not (seq_tm t1)
									  t1 / st --> t1' / st'
								--------------------------------   (ST_Seq2)
								seq t1 t2 / st --> seq t1' t2 / st'
								
												yield_tm v1
								--------------------------------   (ST_Seq3)
								seq v1 t2 / st 
									--> pair v1 (\_:Unit t2) / st
								
											not (yield_tm v1)
								-------------------------------  (ST_Seq4)
									seq v1 t2 / st --> t2 / st

\end{lstlisting}

\subsection{Reference}
\textbf{ST_RefValue}: If v is a value, then return the length is the state list as its location reference and append v to the list.
\textbf{ST_DerefLoc}: If t is a value (loc l) and l is less than the length of the state list, then find the value under the reference cell in the list.
\textbf{ST_Assign}: If l is less than the length of the state list, then replace the value under reference cell (loc l) with v2.
\begin{lstlisting}
Definition store := list tm.
Definition store_lookup (n:nat) (st:store) := nth n st unit.

Reduction:

									----------------------------   (ST_RefValue)
								ref v / st --> loc |st| / st,v1

													t / st --> t' / st'
								----------------------------------  (ST_Ref)
								     ref t / st --> ref t' / st'
								
												t / st --> t' / st
								----------------------------------  (ST_Deref)
												!t / st --> !t' / st'
								
													l < |st|
									----------------------------   (ST_DerefLoc)
							!(loc l) / st --> lookup l st / st
								
											t1 / st --> t1' / st
								----------------------------------  (ST_Assign1)
								t1 := t2 / st --> t1' := t2  / st
								
										t2 / st --> t2' / st
							---------------------------------   (ST_Assign2)
							t1 := t2 / st --> t1 := t2'  / st
								
													l < |st|
								----------------------------------  (ST_Assign)
								loc l := v2 / st --> unit / [l:=v2]st

\end{lstlisting}

\subsection{Let}
\textbf{ST_LetValue}: If v1 is a value, then substitute x with v1 in t2.
\begin{lstlisting}
Reduction:

											t1 / st --> t1' / st'
							----------------------------------  (ST_Let1)
									let x=t1 in t2 / st 
										--> let x=t1' in t2 / st'
						
								----------------------------   (ST_LetValue)
								let x=v1 in t2  / st 
										--> [x:=v1]t2  / st'
\end{lstlisting}

\subsection{Fix}
Lambda calculus is a universal model of computation which is well defined in Chapter \textit{Stlc}. Then, can we define a general recursion with this. Let us define the \textit{fixed point} $Y = \lambda f. (\lambda g. f(g\text{ }g))(\lambda g. f(g\text{ }g))$. Then the recursion function $f$ could be defined as follow:
\begin{align*}
Yf &=  \lambda f. ((\lambda g. f(g\text{ }g))(\lambda g. f(g\text{ }g))) f \\
&=  (\lambda g. f(g\text{ }g))(\lambda g. f(g\text{ }g)) \\
&= f ((\lambda g. f(g\text{ }g))(\lambda g. f(g\text{ }g))) \\
&= f (\lambda f. ((\lambda g. f(g\text{ }g))(\lambda g. f(g\text{ }g))) f ) \\
&= f(Yf)\\
&= f(f(Yf))\\
&= ...
\end{align*}
\begin{lstlisting}
Reduction:

									      t1  / st--> t1' / st'
										---------------------------    (ST_Fix1)
									  fix t1  / st--> fix t1' / st'

				
				-------------------------------------------  (ST_FixAbs)
					fix (\xf:T1.t2) / st --> 
									[xf:=fix (\xf:T1.t2)] t2  / st
\end{lstlisting}

\subsection{While}
Since \while loop can be implemented in recursion as shown below, assume $x$ has a reference type, then we can form a \while function either in induction or a lambda calculus. $P$ is a predicate function of $x$, and $B$ is a body function of $x$.
\begin{lstlisting}
def while (P,B,x) {
		if P(x) do
				B(x); while(P,B,x)
}
\end{lstlisting}
Then, the \while term can be formalized as:
\begin{lstlisting}
while (\x:(Ref T). p) (\x:(Ref T). b) =
fix \f:(Ref T)->Unit. 
		\x:(Ref T). 
		if (\x:(Ref T). p x) 
		do (seq (\x:(Ref T). b x) (f x)) else unit
\end{lstlisting}
In this way, (while P B x) always return a \textit{seq} term or a unit term. 
\begin{lstlisting}
Reduction:

										     t1 / st --> t1' / st'
								--------------------------------- (ST_While1)
								while t1 t2 / st --> while t1' t2 / st'
								
											  t2 / st --> t2' / st'
								--------------------------------- (ST_While2)
								while v1 t2 / st --> while v1 t2' / st'
								
						-------------------------------------- (ST_WhileFix)
					while (\x1:(Ref T). p) (\x2:(Ref T). b) / st 
					--> tfix (\f:(Ref T)->Unit. 
					       	  (\x:(Ref T). (if \x1:(Ref T). p x
																	then seq (\x2:T. b x) (f x)
																  else unit))) / st'
\end{lstlisting}


\subsection{Generator}
\textbf{ST_Gen3}: The \gen term takes a generator function and a corresponding input and returns a reference of a iterable object.
\textbf{ST_Gnext2}: The \nt function takes a \gen term and reduces it into a pair, where the first term the generator's reference and the second is the value under it.
\textbf{ST_Gnext3, ST_Gnext1}: Reduce the body term of the unit function.
\textbf{ST_Gnext4}: If the second term is a \textit{exit} pair, update the generator's reference with the new generator v2 and return v1.
\textbf{ST_Gnext5}: If the second term is a \textit{yield} term, update the generator's reference with unit and return v.
\begin{lstlisting}
Reduction:

										  t1 / st --> t1' / st'
								-------------------------------   (ST_Gen1)
								gen t1 t2 / st --> gen t1' t2 / st'

										t2 / st --> t2' / st'
							---------------------------------   (ST_Gen2)
							gen v1 t2 / st --> gen v1 t2' / st'
							  
							  
						------------------------------------- (ST_Gen3)
						 gen (\x:T. g) v / st
										--> [x:=v]g / st
													
									    t / st --> t' / st'
								------------------------------   (ST_Gyield)
								gyield t / st --> gyield t' / st'
													
										   t / st --> t' / st'
								---------------------------------  (ST_Gnext1)
								gnext t / st --> gnext t' / st'
								

							---------------------------------   (ST_Gnext2)
						gnext (loc l) / st 
							--> gnext (pair (loc l) (deref (loc l)) / st
								
						
				   -------------------------------------   (ST_Gnext3)
				gnext (pair (loc l) (abs "_" Unit t)) / st
						--> gnext (pair (loc l) t) / st
								
					  ------------------------------------    (ST_Gnext4)
					gnext (pair (loc l) (pair (yield v1) v2)) / st
						--> [_:=assign (loc l) (ref v2)]v1 / st
								
								
							----------------------------------   (ST_Gnext5)
							gnext (pair (loc l) (yield v)) / st
							--> [_:=(assign (loc l) unit)]v / st
												
\end{lstlisting}

